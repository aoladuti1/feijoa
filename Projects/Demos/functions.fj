foo = 10;

def func(foo: typeHint = 5, bar=2) {
    sysln!(bar);
    return foo; // it will return 5 - see the way the scope is correct?
}

sysln!(func(bar=700)); // prints 5 and then 700

    /* standard java-style lambda syntax */ 
// ...but see that default args are possible
msgOne = (txt="default") -> { txt += ""; sysln!(txt);  };

// parentheses are optional for a single argument
// curly braces are optional for a single function expression in the body
msgTwo = txt -> sysln!(txt);

msgOne("i am a lambda");
msgTwo(txt="i am also a lambda"); // arg selection still possible

def lambdaCaller(a) { a(); }
lambdaCaller(() -> sysln!("i am a function called with a lambda"));

    /* See Python-style lambdas -- right side is returned, left side is for args */
pyDouble = lambda x : x * 2;
// parentheses optional for any number of args in python-style
pyAdd = lambda x, y -> : x + y; 

sysln!("The double of 10 is " + pyDouble(10));
sysln!(5 + " add " + 5 + " is " + pyAdd(5, 5));

// See nested functions and closures
def printNested() {
    def x() {
        msg = "i was called from a nested function";
        def y() {
            sysln!(msg);
        }
        y();
    }
    return x;
}

def c (x, y) -> int {

}
printNested()();

// New and improved type-hinting!
def ditto1() -> [str] {
    return ["ditto"]; 
}
ditto2 = () -> [str] { return ["ditto"]; }; // ALT.: ditto2 = () -> [str] return ["ditto"];
ditto3 = lambda () -> [RANDOM.TEXT[YO]] : ["ditto"]; // ALT.: lambda -> [RANDOM.TEXT[YO]] : ["ditto"];

sysln!(ditto1() + ditto2() + ditto3());


// Note: ALL arguments without a default specified are defaulted to null