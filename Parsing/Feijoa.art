(*******************************************************************************
*
* feijoa (by antonio oladuti - 2022/23)
* computer science dept. @ royal holloway, university of london
*
*******************************************************************************)
prelude {import java.util.HashMap;}

support { 
	HashMap<String, Object> symbols = new HashMap<String, Object>(); // key, value = identifier, value
	
	Integer iv(Object obj) {
		return Integer.valueOf(obj.toString());
	}
	
	Double dv(Object obj) {
		return Double.valueOf(obj.toString());
	}
	
	Boolean bv(Object obj) {
		String s = obj.toString();
		if (s.equalsIgnoreCase("true"))
			return true;
		if (s.equalsIgnoreCase("false"))
			return false;
		throw new IllegalArgumentException();
	}
}

(* ONLY INTEGERS WORK AT THE MOMENT *)

whitespace &SIMPLE_WHITESPACE
whitespace &COMMENT_LINE_C
whitespace &COMMENT_BLOCK_C

statements ::= statement | statement statements
statement ::= mainExpr | sysout | sysline 

sysout ::= 'sysout' '(' mainExpr ')'
	{ System.out.print(mainExpr1.o); } ';'
	
sysline ::= 'sysline' '(' mainExpr ')'
	{ System.out.println(mainExpr1.o); } ';'
	
mainExpr <o: Object> ::= assign 
	| subExprA { mainExpr.o = subExprA1.o; }


subExprA <o: Object> ::= subExprB { subExprA.o = subExprB1.o; }
	| and { subExprA.o = and1.o; }
	| or  { subExprA.o = or1.o;  }
	| gtr { subExprA.o = gtr1.o; }
	
subExprB <o: Object> ::= subExprC { subExprB.o = subExprC1.o; }
	| plus { subExprB.o = plus1.o; }
	| minus { subExprB.o = minus1.o; }
	
subExprC <o: Object> ::= subExprD { subExprC.o = subExprD1.o; }
	| multiply { subExprC.o = multiply1.o; }

subExprD <o: Object> ::= subExprE { subExprD.o = subExprE1.o; }
	| exponentiate { subExprD.o = exponentiate1.o; }
	
subExprE <o: Object> ::= subExprF { subExprE.o = subExprF1.o; }
	| not { subExprE.o = not1.o; }
	
subExprF <o: Object> ::= operand { subExprF.o = operand1.o; }


		
gtr <o: Object> ::= subExprB '>' subExprB
		{ 	try {
				gtr.o = (Integer.compare(iv(subExprB1.o),
										 iv(subExprB2.o))) > 0;
			} catch (Exception FjException) {
				gtr.o = (Double.compare(dv(subExprB1.o),
										dv(subExprB2.o))) > 0;
			}
		} 		
		
assign <o: Object> ::= ID '<-' subExprA ';' 
		{ symbols.put(ID1.v, subExprA1.o); }
	| plusEquals
	
plusEquals <o: Object> ::= ID '+<-' subExprB ';'
	{ 	try {
			plusEquals.o = (iv(symbols.get(ID1.v))
					+ iv(subExprB1.o));
		} 
		catch (Exception FjException) {
			try {
				plusEquals.o = (dv(symbols.get(ID1.v))
						+ dv(subExprB1.o));
			}
		catch (Exception FjException2) {
			try {
				plusEquals.o = (bv(symbols.get(ID1.v))
					   || bv(subExprB1.o));
			} 
		catch (Exception FJException3) {
				plusEquals.o = symbols.get(ID1.v) + (String) subExprB1.o;
			}
		}
		}
		{symbols.put(ID1.v, plusEquals.o);}
	}	
		
plus <o: Object> ::= subExprB '+' subExprC
	{ 	try {
			plus.o = (iv(subExprB1.o)
					+ iv(subExprC1.o));
		} 
		catch (Exception FjException) {
			try {
				plus.o = (dv(subExprB1.o)
						+ dv(subExprC1.o));
			}
		catch (Exception FjException2) {
			try {
				plus.o = (bv(subExprB1.o)
					   || bv(subExprC1.o));
			} 
		catch (Exception FJException3) {
				plus.o = (String) subExprB1.o + (String) subExprC1.o;
			}
		}
		}
	}	
					
minus <o: Object> ::= subExprB '-' subExprC
	{ 	try {
			minus.o = (iv(subExprB1.o)
					- iv(subExprC1.o));
		} 
		catch (Exception FjException) {
			try {
				minus.o = (dv(subExprB1.o)
						- dv(subExprC1.o));
			} 
			catch (Exception FJException2) {
				String str1 = (String) subExprB1.o;
				String str2 = (String) subExprC1.o;
				minus.o = str1.replace(str2, "");
			}
		}
	}
	
multiply <o: Object> ::= subExprC '*' subExprD
	{ 	try {
			multiply.o = (iv(subExprC1.o)
					    * iv(subExprD1.o));
		} 
		catch (Exception FjException) {
			try {
				multiply.o = (dv(subExprC1.o)
							* dv(subExprD1.o));
			}
		catch (Exception FJException2) {
			multiply.o = (bv(subExprC1.o)
						&& bv(subExprD1.o));
			}
		}
	}
		
exponentiate <o: Object> ::= subExprE '**' subExprD
		{ 	try {
				exponentiate.o = Math.pow(
					iv(subExprE1.o)
						, iv(subExprD1.o));
			} 
			catch (Exception FjException) {
				exponentiate.o = Math.pow(
					dv(subExprE1.o)
						, dv(subExprD1.o));
			}
		}
		
not <o: Object> ::= '!' subExprE
	{ not.o = !(bv(subExprE1.o)); }
	
and <o: Object> ::= subExprA '&&' subExprA 
	{ and.o = (bv(subExprA1.o)
			&& bv(subExprA2.o)); }
			
or <o: Object> ::= subExprA '||' subExprA 
	{ or.o = bv(subExprA1.o) || bv(subExprA2.o); }
	
operand <o: Object> ::= deref { operand.o = symbols.get(deref1.v); }
	| INTEGER
		{ operand.o = INTEGER1.v; }
	| REAL
		{ operand.o = REAL1.v; }
	| 'true'
		{ operand.o = bv(true); }
	| 'false'
		{ operand.o = bv(false); }
	| STRING_DQ
		{ operand.o = STRING_DQ1.v; }
	| '(' mainExpr ')'
		{ operand.o = mainExpr1.o; }
	| #
	
		
deref <v: String> ::= ID
	{ deref.v = ID1.v; }

ID <leftExtent:int rightExtent:int lexeme:String v:String> ::= 
  &ID {ID.lexeme = artLexeme(ID.leftExtent, ID.rightExtent); ID.v = artLexemeAsID(ID.leftExtent, ID.rightExtent); }  

INTEGER <leftExtent:int rightExtent:int lexeme:String v:int> ::= 
  &INTEGER {INTEGER.lexeme = artLexeme(INTEGER.leftExtent, INTEGER.rightExtent); INTEGER.v = artLexemeAsInteger(INTEGER.leftExtent, INTEGER.rightExtent); }  

REAL <leftExtent:int rightExtent:int lexeme:String v:Double> ::= 
  &REAL {REAL.lexeme = artLexeme(REAL.leftExtent, REAL.rightExtent); REAL.v = artLexemeAsReal(REAL.leftExtent, REAL.rightExtent); }
  
STRING_DQ <leftExtent:int rightExtent:int lexeme:String v:String> ::= 
  &STRING_DQ {STRING_DQ.lexeme = artLexeme(STRING_DQ.leftExtent, STRING_DQ.rightExtent); STRING_DQ.v = artLexemeAsString(STRING_DQ.leftExtent, STRING_DQ.rightExtent); }