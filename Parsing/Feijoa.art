(*******************************************************************************
*
* feijoa (by antonio oladuti - 2022/23)
* computer science dept. @ royal holloway, university of london
*
*******************************************************************************)
prelude {import java.util.HashMap; import java.util.ArrayList;}

support { 
	final String NO_ARG = "|__FJNOARG__|";
	// Helper classes: FJ.java
	
}

whitespace &SIMPLE_WHITESPACE
whitespace &COMMENT_LINE_C
whitespace &COMMENT_BLOCK_C

statements ::= statement | statement statements
compStatements ::= '{' statements '}' | statement
statement ::= defStruct | loopStatement | condStatement | mainExpr | sysout | sysline

structDefinition ::= '{' structStatements '}' statements | structStatement statements
structStatements ::= structStatement | structStatement structStatements
structStatement ::= memberAssign

defStruct ::= 'struct' ID 
		{	try { 
				FJ.declareStruct(ID1.v); 
			} catch (Exception FJException) {
				System.err.println(FJException);
			}
			while (!FJ.curdef.equals(""))
				{ try {Thread.sleep(1);} catch (Exception __) {} } 
			FJ.curdef = ID1.v;
		} structDefinition { FJ.curdef = ""; }

loopStatement ::= whileExpr< compStatements<
		{	artEvaluate(
					loopStatement.whileExpr1, whileExpr1);
			while (FJ.bv(whileExpr1.o) == true) { 
				artEvaluate(
					loopStatement.compStatements1, compStatements1); 
                artEvaluate(
					loopStatement.whileExpr1, whileExpr1); 
            }
		}
	| untilExpr< compStatements<
		{	artEvaluate(
					loopStatement.untilExpr1, untilExpr1);
			while (FJ.bv(untilExpr1.o) == false) { 
				artEvaluate(
					loopStatement.compStatements1, compStatements1); 
                artEvaluate(
					loopStatement.untilExpr1, untilExpr1); 
            }
		}

condStatement ::= ifExpr compStatements< 
		{	if (FJ.bv(ifExpr1.o) == true) {
				artEvaluate(condStatement.compStatements1, compStatements1); 
			}
		}
	ifExpr compStatements< elifExpr compStatements<
		{ if (FJ.bv(ifExpr1.o) == true) {
			artEvaluate(condStatement.compStatements1, compStatements1); 
			}
		  else if (FJ.bv(elifExpr1.o)== true){
			artEvaluate(condStatement.compStatements2, compStatements2);  
		  }
		}
	| elifExpr compStatements< elifExpr compStatements<
		{	
			if (FJ.bv(elifExpr1.o) == false && FJ.bv(elifExpr2.o) == true) {
				artEvaluate(condStatement.compStatements2, compStatements2); 
			}
		}
	| ifExpr compStatements< 'else' compStatements<
		{
			if (FJ.bv(ifExpr1.o) == false) {
				artEvaluate(condStatement.compStatements2, compStatements2);
			} else {
				artEvaluate(condStatement.compStatements1, compStatements1);
			}
		}
	| elifExpr compStatements< 'else' compStatements<
		{
			if (FJ.bv(elifExpr1.o) == false) {
				artEvaluate(condStatement.compStatements2, compStatements2);
			}
		}
		
		
whileExpr <o: Object> ::= 'while' mainExpr
	{ whileExpr.o = mainExpr1.o; }

untilExpr <o: Object> ::= 'until' mainExpr
	{ untilExpr.o = mainExpr1.o; }
	
ifExpr <o: Object> ::= 'if' mainExpr
	{ ifExpr.o = mainExpr1.o; }
	
elifExpr <o: Object> ::= 'elif' mainExpr
	{ elifExpr.o = mainExpr1.o; }
	
	
sysout ::= 'sysout' '(' mainExpr ')'
	{ System.out.print(mainExpr1.o); } ';'
	
sysline ::= 'sysline' '(' mainExpr ')'
	{ System.out.println(mainExpr1.o); } ';'
	

memberAssign ::= ID '=' subExprA ';' 
		{ FJ.addMember(FJ.curdef, ID1.v, subExprA1.o); }
	
mainExpr <o: Object> ::= assign 
	| subExprA { mainExpr.o = subExprA1.o; }

subExprA <o: Object> ::= subExprB { subExprA.o = subExprB1.o; }
	| and { subExprA.o = and1.o; }
	| or  { subExprA.o = or1.o;  }
	| gtr { subExprA.o = gtr1.o; }
	| equ { subExprA.o = equ1.o; }
	
subExprB <o: Object> ::= subExprC { subExprB.o = subExprC1.o; }
	| plus { subExprB.o = plus1.o; }
	| minus { subExprB.o = minus1.o; }
	
subExprC <o: Object> ::= subExprD { subExprC.o = subExprD1.o; }
	| multiply { subExprC.o = multiply1.o; }

subExprD <o: Object> ::= subExprE { subExprD.o = subExprE1.o; }
	| exponentiate { subExprD.o = exponentiate1.o; }
	
subExprE <o: Object> ::= subExprF { subExprE.o = subExprF1.o; }
	| not { subExprE.o = not1.o; }
	| negate { subExprE.o = negate1.o; }
	
subExprF <o: Object> ::= operand { subExprF.o = operand1.o; }

equ <o: Object> ::= subExprB '==' subExprB
	{ equ.o = FJ.equ(subExprB1.o, subExprB2.o); }

gtr <o: Object> ::= subExprB '>' subExprB
	{ gtr.o = FJ.gtr(subExprB1.o, subExprB2.o); }
		
assign ::= AID '=' subExprA ';' 
		{ FJ.putSymbol(AID1.v, subExprA1.o); }
	| structAssign
	| plusEquals
	| minusEquals
	
structAssign ::= ID
		{ FJ.putSymbol(ID1.v, new HashMap<String, Object>()); }
	  '<-' ID {	while (!FJ.curdef.equals("") && !FJ.curID.equals(""))
					try {Thread.sleep(1);} catch (Exception __) {}
				FJ.curID = ID1.v;
				FJ.curdef = ID2.v; 
				FJ.argIndex = -1;
				FJ.argCount = 0;
			  }
	  '(' structArgs ')' {
		  if (FJ.argCount < 0) {
				FJ.symbols.remove(FJ.curID);
				return;
		  }
	      ArrayList<FJNamedObj> classMemberVars = FJ.structsMValues.get(FJ.curdef);
		  int maxArgs = classMemberVars.size();
		  @SuppressWarnings("unchecked")
		  HashMap<String, Object> curIDMembers
			= (HashMap<String, Object>) FJ.symbols.get(FJ.curID);
		  FJNamedObj classMember;
		  for (int i = FJ.argCount; i < maxArgs; i++) {
		      classMember = classMemberVars.get(i);
			  curIDMembers.put(classMember.name, classMember.obj);
		  }
		}

	   ';' {FJ.curdef = ""; FJ.curID = ""; FJ.argIndex = -1; FJ.argCount = 0; }
	
structArgs <c:int> ::= arg ',' structArgs
		{ ArrayList<FJNamedObj> classMemberVars = FJ.structsMValues.get(FJ.curdef);
	      int maxArgs = classMemberVars.size();
		  FJ.argIndex--;
		  FJNamedObj curNamedObj;
		  try {
			curNamedObj = classMemberVars.get(FJ.argIndex);
		  } catch (Exception FJException) {
			return;
		  }
		  String curMemberName = curNamedObj.name;
		  Object curMemberObj = arg1.o;
		  @SuppressWarnings("unchecked")
		  HashMap<String, Object> curIDMembers 
		      = (HashMap<String, Object>) FJ.symbols.get(FJ.curID);
		  curIDMembers.put(curMemberName, curMemberObj);
		  // curIDMembers is the memberName, memberObject hashmap of the variable
	  }
	| arg 
		{ if (FJ.argIndex == -1) {
		      FJ.argIndex = FJ.argCount;
		  }
		  ArrayList<FJNamedObj> classMemberVars1 = FJ.structsMValues.get(FJ.curdef);
		  int maxArgs1 = classMemberVars1.size();
		  if (FJ.argCount > maxArgs1) {
			  System.err.println(
			      "ArgError: [" + FJ.curID
				+ "] too many arguments for struct type " + FJ.curdef
				+ " (got " + FJ.argCount + "; expected up to " + maxArgs1 + ")");
			  FJ.argCount = -1;
			  return;
		  }
		  Object curMemberObj1;
		  if (NO_ARG.equals(arg1.o.toString())) {
			  return;
		  } else {
	          curMemberObj1 = arg1.o;
			  FJ.argIndex--;
		  }

		  FJNamedObj curNamedObj1 = classMemberVars1.get(FJ.argIndex);
		  String curMemberName1 = curNamedObj1.name;
		  @SuppressWarnings("unchecked")
		  HashMap<String, Object> curIDMembers1 
		      = (HashMap<String, Object>) FJ.symbols.get(FJ.curID);
		  curIDMembers1.put(curMemberName1, curMemberObj1);
	 }
arg <o: Object> ::=  # { arg.o = NO_ARG; } 
	| subExprA typeNote { arg.o = subExprA1.o; FJ.argCount++; }

typeNote ::= ':' ID | #
	
plusEquals <o: Object> ::= AID '+=' subExprC ';'	
	{ FJ.putSymbol(AID1.v, FJ.plus(FJ.getSymbol(AID1.v), subExprC1.o)); }
	
minusEquals <o: Object> ::= AID '-=' subExprC ';'
	{ FJ.putSymbol(AID1.v, FJ.minus(FJ.getSymbol(AID1.v), subExprC1.o)); }
		
plus <o: Object> ::= subExprB '+' subExprC
	{ plus.o = FJ.plus(subExprB1.o, subExprC1.o); }	
					
minus <o: Object> ::= subExprB '-' subExprC
	{ minus.o = FJ.minus(subExprB1.o, subExprC1.o); }
	
multiply <o: Object> ::= subExprC '*' subExprD
	{ multiply.o = FJ.multiply(subExprC1.o, subExprD1.o); }
		
exponentiate <o: Object> ::= subExprE '**' subExprD
	{ exponentiate.o = FJ.exponentiate(subExprE1.o, subExprD1.o); }
		
not <o: Object> ::= '!' subExprE
	{ not.o = !(FJ.bv(subExprE1.o)); }
	
negate <o: Object> ::= '-' subExprE
	{	try {
			negate.o = FJ.iv(subExprE1.o) * -1; 
		} catch (Exception FJException) {
			negate.o = FJ.dv(subExprE1.o) * -1;
		}
	}
	
and <o: Object> ::= subExprA '&&' subExprA 
	{ and.o = (FJ.bv(subExprA1.o)
			&& FJ.bv(subExprA2.o)); }

or <o: Object> ::= subExprA '||' subExprA 
	{ or.o = FJ.bv(subExprA1.o) || FJ.bv(subExprA2.o); }
	
operand <o: Object> ::= deref { operand.o = FJ.getSymbol(deref1.v); }
	| INTEGER
		{ operand.o = INTEGER1.v; }
	| REAL
		{ operand.o = REAL1.v; }
	| 'true'
		{ operand.o = FJ.bv(true); }
	| 'false'
		{ operand.o = FJ.bv(false); }
	| STRING_DQ
		{ operand.o = STRING_DQ1.v; }
	| '(' mainExpr ')'
		{ operand.o = mainExpr1.o; }
	| #
		
deref <v: String> ::= AID
	{ deref.v = AID1.v; }
	
AID <v:String> ::= ID { AID.v = ID1.v; } | ID '.' ID { AID.v = ID1.v + '.' + ID2.v; }

ID <leftExtent:int rightExtent:int lexeme:String v:String> ::= 
  &ID {ID.lexeme = artLexeme(ID.leftExtent, ID.rightExtent); ID.v = artLexemeAsID(ID.leftExtent, ID.rightExtent); }  

INTEGER <leftExtent:int rightExtent:int lexeme:String v:int> ::= 
  &INTEGER {INTEGER.lexeme = artLexeme(INTEGER.leftExtent, INTEGER.rightExtent); INTEGER.v = artLexemeAsInteger(INTEGER.leftExtent, INTEGER.rightExtent); }  

REAL <leftExtent:int rightExtent:int lexeme:String v:Double> ::= 
  &REAL {REAL.lexeme = artLexeme(REAL.leftExtent, REAL.rightExtent); REAL.v = artLexemeAsReal(REAL.leftExtent, REAL.rightExtent); }
  
STRING_DQ <leftExtent:int rightExtent:int lexeme:String v:String> ::= 
  &STRING_DQ {STRING_DQ.lexeme = artLexeme(STRING_DQ.leftExtent, STRING_DQ.rightExtent); STRING_DQ.v = artLexemeAsString(STRING_DQ.leftExtent, STRING_DQ.rightExtent); }